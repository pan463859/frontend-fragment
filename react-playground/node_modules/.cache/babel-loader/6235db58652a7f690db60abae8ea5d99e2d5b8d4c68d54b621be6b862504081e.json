{"ast":null,"code":"var _jsxFileName = \"/Users/panan/workspace/react-playground/src/virtualList/VariableSizeList.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport './style.css';\n\n// 元数据\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst measuredData = {\n  measuredDataMap: {},\n  lastMeasuredItemIndex: -1\n};\nconst estimatedHeight = function () {\n  let defaultEstimatedItemSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n  let itemCount = arguments.length > 1 ? arguments[1] : undefined;\n  let measuredHeight = 0;\n  const {\n    measuredDataMap,\n    lastMeasuredItemIndex\n  } = measuredData;\n  // 计算已经获取过真实高度的项的高度之和\n  if (lastMeasuredItemIndex >= 0) {\n    const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n    measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;\n  }\n  // 未计算过真实高度的项数\n  const unMeasuredItemsCount = itemCount - measuredData.lastMeasuredItemIndex - 1;\n  // 预测总高度\n  // 已经渲染过的，可以得到实际高度的情况下可以直接通过计算实际高度+部分预测来判断最大高度\n  const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;\n  return totalEstimatedHeight;\n};\nconst getItemMetaData = (props, index) => {\n  const {\n    itemSize,\n    itemEstimatedSize\n  } = props;\n  const {\n    measuredDataMap,\n    lastMeasuredItemIndex\n  } = measuredData;\n  // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的size和offset\n  if (index > lastMeasuredItemIndex) {\n    let offset = 0;\n    // 计算当前能计算出来的最大offset值\n    if (lastMeasuredItemIndex > 0) {\n      const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n      offset += lastMeasuredItem.offset + lastMeasuredItem.size;\n    }\n    // 计算直到index为止，所有未计算过的项\n    for (let i = lastMeasuredItemIndex + 1; i <= index; i++) {\n      const currentItemSize = itemSize ? itemSize(i) : itemEstimatedSize;\n      measuredDataMap[i] = {\n        size: currentItemSize,\n        offset\n      };\n      offset += currentItemSize;\n    }\n    // 更新已计算的项的索引值\n    measuredData.lastMeasuredItemIndex = index;\n  }\n  return measuredDataMap[index];\n};\nconst getStartIndex = (props, scrollOffset) => {\n  let index = 0;\n  while (true) {\n    const currentOffset = getItemMetaData(props, index).offset;\n    if (currentOffset >= scrollOffset) return index;\n    index++;\n  }\n};\nconst getEndIndex = (props, startIndex) => {\n  const {\n    height,\n    itemCount\n  } = props;\n  // 获取可视区内开始的项\n  const startItem = getItemMetaData(props, startIndex);\n  // 可视区内最大的offset值\n  const maxOffset = startItem.offset + height;\n  // 开始项的下一项的offset，之后不断累加此offset，知道等于或超过最大offset，就是找到结束索引了\n  let offset = startItem.offset + startItem.size;\n  // 结束索引\n  let endIndex = startIndex;\n  // 累加offset\n  while (offset <= maxOffset && endIndex <= itemCount - 1) {\n    endIndex++;\n    const currentItem = getItemMetaData(props, endIndex);\n    offset += currentItem.size;\n  }\n  return endIndex;\n};\nconst getRangeToRender = (props, scrollOffset) => {\n  const {\n    itemCount\n  } = props;\n  const startIndex = getStartIndex(props, scrollOffset);\n  const endIndex = getEndIndex(props, startIndex);\n  return [Math.max(0, startIndex - 2), Math.min(itemCount - 1, endIndex + 2), startIndex, endIndex];\n};\nclass ListItem extends React.Component {\n  constructor(props) {\n    super(props);\n    this.domRef = /*#__PURE__*/React.createRef();\n    this.resizeObserver = null;\n  }\n  componentDidMount() {\n    if (this.domRef.current) {\n      const domNode = this.domRef.current.firstChild;\n      const {\n        index,\n        onSizeChange\n      } = this.props;\n      this.resizeObserver = new ResizeObserver(() => {\n        onSizeChange(index, domNode);\n      });\n      this.resizeObserver.observe(domNode);\n    }\n  }\n  componentWillUnmount() {\n    if (this.resizeObserver && this.domRef.current.firstChild) {\n      this.resizeObserver.unobserve(this.domRef.current.firstChild);\n    }\n  }\n  render() {\n    const {\n      index,\n      style,\n      ComponentType\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: style,\n      ref: this.domRef,\n      children: /*#__PURE__*/_jsxDEV(ComponentType, {\n        index: index\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 7\n    }, this);\n  }\n}\nconst _VariableSizeList = props => {\n  _s();\n  const {\n    height,\n    width,\n    itemCount,\n    itemEstimatedSize = 50,\n    children: Child\n  } = props;\n  const [scrollOffset, setScrollOffset] = useState(0);\n  const [, setState] = useState({});\n  const containerStyle = {\n    position: 'relative',\n    width,\n    height,\n    overflow: 'auto',\n    willChange: 'transform'\n  };\n  const contentStyle = {\n    height: estimatedHeight(itemEstimatedSize, itemCount),\n    width: '100%'\n  };\n  const getCurrentChildren = () => {\n    const [startIndex, endIndex] = getRangeToRender(props, scrollOffset);\n    const items = [];\n    for (let i = startIndex; i <= endIndex; i++) {\n      const item = getItemMetaData(props, i);\n      const itemStyle = {\n        position: 'absolute',\n        height: item.size,\n        width: '100%',\n        top: item.offset\n      };\n      items.push( /*#__PURE__*/_jsxDEV(ListItem, {\n        index: i,\n        style: itemStyle,\n        ComponentType: Child,\n        onSizeChange: sizeChangeHandle\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 150,\n        columnNumber: 9\n      }, this));\n    }\n    return items;\n  };\n  // 增加sizeChangeHandle\n  const sizeChangeHandle = (index, domNode) => {\n    const height = domNode.offsetHeight;\n    const {\n      measuredDataMap,\n      lastMeasuredItemIndex\n    } = measuredData;\n    const itemMetaData = measuredDataMap[index];\n    itemMetaData.size = height;\n    let offset = 0;\n    for (let i = 0; i <= lastMeasuredItemIndex; i++) {\n      const itemMetaData = measuredDataMap[i];\n      itemMetaData.offset = offset;\n      offset += itemMetaData.size;\n    }\n    setState({});\n  };\n  const scrollHandle = event => {\n    const {\n      scrollTop\n    } = event.currentTarget;\n    setScrollOffset(scrollTop);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: containerStyle,\n    onScroll: scrollHandle,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: contentStyle,\n      children: getCurrentChildren()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 176,\n    columnNumber: 5\n  }, this);\n};\n_s(_VariableSizeList, \"YLO7FFHwBQM79VE0W384EU/AKw0=\");\nconst VariableSizeList = () => {\n  const items = [];\n  const itemCount = 1000;\n  for (let i = 0; i < itemCount; i++) {\n    const height = 30 + Math.floor(Math.random() * 30);\n    const style = {\n      height,\n      width: '100%'\n    };\n    items.push( /*#__PURE__*/_jsxDEV(\"div\", {\n      className: i % 2 ? 'list-item-odd' : 'list-item-even',\n      style: style,\n      children: [\"Row \", i]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 7\n    }, this));\n  }\n  const Row = _ref => {\n    let {\n      index\n    } = _ref;\n    return items[index];\n  };\n  // 注意：这里我没有把itemSize传过去\n  return /*#__PURE__*/_jsxDEV(_VariableSizeList, {\n    className: \"list\",\n    height: 200,\n    width: 200,\n    itemCount: itemCount,\n    isDynamic: true,\n    children: Row\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 202,\n    columnNumber: 5\n  }, this);\n};\n_c = VariableSizeList;\nexport default VariableSizeList;\nvar _c;\n$RefreshReg$(_c, \"VariableSizeList\");","map":{"version":3,"names":["React","useState","jsxDEV","_jsxDEV","measuredData","measuredDataMap","lastMeasuredItemIndex","estimatedHeight","defaultEstimatedItemSize","arguments","length","undefined","itemCount","measuredHeight","lastMeasuredItem","offset","size","unMeasuredItemsCount","totalEstimatedHeight","getItemMetaData","props","index","itemSize","itemEstimatedSize","i","currentItemSize","getStartIndex","scrollOffset","currentOffset","getEndIndex","startIndex","height","startItem","maxOffset","endIndex","currentItem","getRangeToRender","Math","max","min","ListItem","Component","constructor","domRef","createRef","resizeObserver","componentDidMount","current","domNode","firstChild","onSizeChange","ResizeObserver","observe","componentWillUnmount","unobserve","render","style","ComponentType","ref","children","fileName","_jsxFileName","lineNumber","columnNumber","_VariableSizeList","_s","width","Child","setScrollOffset","setState","containerStyle","position","overflow","willChange","contentStyle","getCurrentChildren","items","item","itemStyle","top","push","sizeChangeHandle","offsetHeight","itemMetaData","scrollHandle","event","scrollTop","currentTarget","onScroll","VariableSizeList","floor","random","className","Row","_ref","isDynamic","_c","$RefreshReg$"],"sources":["/Users/panan/workspace/react-playground/src/virtualList/VariableSizeList.jsx"],"sourcesContent":["import React, { useState } from 'react';\nimport './style.css'\n\n// 元数据\nconst measuredData = {\n  measuredDataMap: {},\n  lastMeasuredItemIndex: -1,\n};\n\nconst estimatedHeight = (defaultEstimatedItemSize = 50, itemCount) => {\n  let measuredHeight = 0;\n  const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n  // 计算已经获取过真实高度的项的高度之和\n  if (lastMeasuredItemIndex >= 0) {\n    const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n    measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;\n  }\n  // 未计算过真实高度的项数\n  const unMeasuredItemsCount = itemCount - measuredData.lastMeasuredItemIndex - 1;\n  // 预测总高度\n  // 已经渲染过的，可以得到实际高度的情况下可以直接通过计算实际高度+部分预测来判断最大高度\n  const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;\n  return totalEstimatedHeight;\n}\n\nconst getItemMetaData = (props, index) => {\n  const { itemSize, itemEstimatedSize } = props;\n  const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n  // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的size和offset\n  if (index > lastMeasuredItemIndex) {\n    let offset = 0;\n    // 计算当前能计算出来的最大offset值\n    if (lastMeasuredItemIndex > 0) {\n      const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n      offset += lastMeasuredItem.offset + lastMeasuredItem.size;\n    }\n    // 计算直到index为止，所有未计算过的项\n    for (let i = lastMeasuredItemIndex + 1; i <= index; i++) {\n      const currentItemSize = itemSize ? itemSize(i) : itemEstimatedSize;\n      measuredDataMap[i] = { size: currentItemSize, offset };\n      offset += currentItemSize;\n    }\n    // 更新已计算的项的索引值\n    measuredData.lastMeasuredItemIndex = index;\n  }\n  return measuredDataMap[index];\n};\n\nconst getStartIndex = (props, scrollOffset) => {\n  let index = 0;\n  while (true) {\n    const currentOffset = getItemMetaData(props, index).offset;\n    if (currentOffset >= scrollOffset) return index;\n    index++\n  }\n}\n\nconst getEndIndex = (props, startIndex) => {\n  const { height, itemCount } = props;\n  // 获取可视区内开始的项\n  const startItem = getItemMetaData(props, startIndex);\n  // 可视区内最大的offset值\n  const maxOffset = startItem.offset + height;\n  // 开始项的下一项的offset，之后不断累加此offset，知道等于或超过最大offset，就是找到结束索引了\n  let offset = startItem.offset + startItem.size;\n  // 结束索引\n  let endIndex = startIndex;\n  // 累加offset\n  while (offset <= maxOffset && endIndex <= itemCount - 1) {\n    endIndex++;\n    const currentItem = getItemMetaData(props, endIndex);\n    offset += currentItem.size;\n  }\n  return endIndex;\n};\n\nconst getRangeToRender = (props, scrollOffset) => {\n  const { itemCount } = props;\n  const startIndex = getStartIndex(props, scrollOffset);\n  const endIndex = getEndIndex(props, startIndex);\n  return [\n    Math.max(0, startIndex - 2),\n    Math.min(itemCount - 1, endIndex + 2),\n    startIndex,\n    endIndex,\n  ];\n};\n\nclass ListItem extends React.Component {\n  constructor(props) {\n    super(props);\n    this.domRef = React.createRef();\n    this.resizeObserver = null;\n  }\n  componentDidMount() {\n    if (this.domRef.current) {\n      const domNode = this.domRef.current.firstChild;\n      const { index, onSizeChange } = this.props;\n      this.resizeObserver = new ResizeObserver(() => {\n        onSizeChange(index, domNode);\n      });\n      this.resizeObserver.observe(domNode);\n    }\n  }\n  componentWillUnmount() {\n    if (this.resizeObserver && this.domRef.current.firstChild) {\n      this.resizeObserver.unobserve(this.domRef.current.firstChild);\n    }\n  }\n  render() {\n    const { index, style, ComponentType } = this.props;\n    return (\n      <div style={style} ref={this.domRef}>\n        <ComponentType index={index} />\n      </div>\n    )\n  }\n}\n\nconst _VariableSizeList = (props) => {\n  const { height, width, itemCount, itemEstimatedSize = 50, children: Child } = props;\n  const [scrollOffset, setScrollOffset] = useState(0);\n  const [, setState] = useState({});\n\n  const containerStyle = {\n    position: 'relative',\n    width,\n    height,\n    overflow: 'auto',\n    willChange: 'transform'\n  };\n\n  const contentStyle = {\n    height: estimatedHeight(itemEstimatedSize, itemCount),\n    width: '100%',\n  };\n\n  const getCurrentChildren = () => {\n    const [startIndex, endIndex] = getRangeToRender(props, scrollOffset)\n    const items = [];\n    for (let i = startIndex; i <= endIndex; i++) {\n      const item = getItemMetaData(props, i);\n      const itemStyle = {\n        position: 'absolute',\n        height: item.size,\n        width: '100%',\n        top: item.offset,\n      };\n      items.push(\n        <ListItem key={i} index={i} style={itemStyle} ComponentType={Child} onSizeChange={sizeChangeHandle} />\n      );\n    }\n    return items;\n  }\n  // 增加sizeChangeHandle\n  const sizeChangeHandle = (index, domNode) => {\n    const height = domNode.offsetHeight;\n    const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n    const itemMetaData = measuredDataMap[index];\n    itemMetaData.size = height;\n    let offset = 0;\n    for (let i = 0; i <= lastMeasuredItemIndex; i++) {\n      const itemMetaData = measuredDataMap[i];\n      itemMetaData.offset = offset;\n      offset += itemMetaData.size;\n    }\n    setState({});\n  }\n\n  const scrollHandle = (event) => {\n    const { scrollTop } = event.currentTarget;\n    setScrollOffset(scrollTop);\n  }\n\n  return (\n    <div style={containerStyle} onScroll={scrollHandle}>\n      <div style={contentStyle}>\n        {getCurrentChildren()}\n      </div>\n    </div>\n  );\n};\n\n\nconst VariableSizeList = () => {\n  const items = [];\n  const itemCount = 1000;\n  for (let i = 0; i < itemCount; i++) {\n    const height = (30 + Math.floor(Math.random() * 30));\n    const style = {\n      height,\n      width: '100%',\n    }\n    items.push(\n      <div className={i % 2 ? 'list-item-odd' : 'list-item-even'} style={style}>Row {i}</div>\n    )\n  }\n\n  const Row = ({ index }) => items[index];\n  // 注意：这里我没有把itemSize传过去\n  return (\n    <_VariableSizeList\n      className=\"list\"\n      height={200}\n      width={200}\n      itemCount={itemCount}\n      isDynamic\n    >\n      {Row}\n    </_VariableSizeList>\n  );\n}\n\nexport default VariableSizeList;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}