{"ast":null,"code":"var _jsxFileName = \"/Users/panan/workspace/react-playground/src/virtualList/VariableSizeList.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\n\n// 元数据\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst measuredData = {\n  measuredDataMap: {},\n  lastMeasuredItemIndex: -1\n};\nconst estimatedHeight = function () {\n  let defaultEstimatedItemSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n  let itemCount = arguments.length > 1 ? arguments[1] : undefined;\n  let measuredHeight = 0;\n  const {\n    measuredDataMap,\n    lastMeasuredItemIndex\n  } = measuredData;\n  // 计算已经获取过真实高度的项的高度之和\n  if (lastMeasuredItemIndex >= 0) {\n    const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n    measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;\n  }\n  // 未计算过真实高度的项数\n  const unMeasuredItemsCount = itemCount - measuredData.lastMeasuredItemIndex - 1;\n  // 预测总高度\n  // 已经渲染过的，可以得到实际高度的情况下可以直接通过计算实际高度+部分预测来判断最大高度\n  const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;\n  return totalEstimatedHeight;\n};\nconst getItemMetaData = (props, index) => {\n  const {\n    itemSize,\n    itemEstimatedSize\n  } = props;\n  const {\n    measuredDataMap,\n    lastMeasuredItemIndex\n  } = measuredData;\n  // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的size和offset\n  if (index > lastMeasuredItemIndex) {\n    let offset = 0;\n    // 计算当前能计算出来的最大offset值\n    if (lastMeasuredItemIndex > 0) {\n      const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n      offset += lastMeasuredItem.offset + lastMeasuredItem.size;\n    }\n    // 计算直到index为止，所有未计算过的项\n    for (let i = lastMeasuredItemIndex + 1; i <= index; i++) {\n      const currentItemSize = itemSize ? itemSize(i) : itemEstimatedSize;\n      measuredDataMap[i] = {\n        size: currentItemSize,\n        offset\n      };\n      offset += currentItemSize;\n    }\n    // 更新已计算的项的索引值\n    measuredData.lastMeasuredItemIndex = index;\n  }\n  return measuredDataMap[index];\n};\nconst getStartIndex = (props, scrollOffset) => {\n  let index = 0;\n  while (true) {\n    const currentOffset = getItemMetaData(props, index).offset;\n    if (currentOffset >= scrollOffset) return index;\n    index++;\n  }\n};\nconst getEndIndex = (props, startIndex) => {\n  const {\n    height\n  } = props;\n  // 获取可视区内开始的项\n  const startItem = getItemMetaData(props, startIndex);\n  // 可视区内最大的offset值\n  const maxOffset = startItem.offset + height;\n  // 开始项的下一项的offset，之后不断累加此offset，知道等于或超过最大offset，就是找到结束索引了\n  let offset = startItem.offset + startItem.size;\n  // 结束索引\n  let endIndex = startIndex;\n  // 累加offset\n  while (offset <= maxOffset) {\n    endIndex++;\n    const currentItem = getItemMetaData(props, endIndex);\n    offset += currentItem.size;\n  }\n  return endIndex;\n};\nconst getRangeToRender = (props, scrollOffset) => {\n  const {\n    itemCount\n  } = props;\n  const startIndex = getStartIndex(props, scrollOffset);\n  const endIndex = getEndIndex(props, startIndex);\n  return [Math.max(0, startIndex - 2), Math.min(itemCount - 1, endIndex + 2), startIndex, endIndex];\n};\nconst ListItem = props => {\n  _s();\n  const {\n    index,\n    style,\n    ComponentType\n  } = props;\n  const domRef = useRef(null);\n  const resizeObserver = useRef(null);\n  useEffect(() => {\n    if (domRef.current) {\n      const domNode = domRef.current.firstChild;\n      const {\n        index,\n        onSizeChange\n      } = props;\n      resizeObserver = new ResizeObserver(() => {\n        onSizeChange(index, domNode);\n      });\n      resizeObserver.observe(domNode);\n    }\n    return () => {\n      if (resizeObserver && domRef.current.firstChild) {\n        resizeObserver.unobserve(domRef.current.firstChild);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: style,\n    ref: domRef,\n    children: /*#__PURE__*/_jsxDEV(ComponentType, {\n      index: index\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 108,\n    columnNumber: 5\n  }, this);\n};\n_s(ListItem, \"lOen6OW7223ly2Zssd2j2j2rQsg=\");\n_c = ListItem;\nconst _VariableSizeList = props => {\n  _s2();\n  const {\n    height,\n    width,\n    itemCount,\n    itemEstimatedSize = 50,\n    children: Child\n  } = props;\n  const [scrollOffset, setScrollOffset] = useState(0);\n  const [, setState] = useState({});\n  const containerStyle = {\n    position: 'relative',\n    width,\n    height,\n    overflow: 'auto',\n    willChange: 'transform'\n  };\n  const contentStyle = {\n    height: estimatedHeight(itemEstimatedSize, itemCount),\n    width: '100%'\n  };\n  const sizeChangeHandle = (index, domNode) => {\n    const height = domNode.offsetHeight;\n    const {\n      measuredDataMap,\n      lastMeasuredItemIndex\n    } = measuredData;\n    const itemMetaData = measuredDataMap[index];\n    itemMetaData.size = height;\n    let offset = 0;\n    for (let i = 0; i <= lastMeasuredItemIndex; i++) {\n      const itemMetaData = measuredDataMap[i];\n      itemMetaData.offset = offset;\n      offset += itemMetaData.size;\n    }\n    setState({});\n  };\n  // 重点看这个函数，如何在初始化的时候拿到开始和结束的 index，如何初始化高度数组，如何管理 offset 和 scrolltop 的关系\n  const getCurrentChildren = () => {\n    const [startIndex, endIndex] = getRangeToRender(props, scrollOffset);\n    const items = [];\n    for (let i = startIndex; i <= endIndex; i++) {\n      const item = getItemMetaData(props, i);\n      const itemStyle = {\n        position: 'absolute',\n        height: item.size,\n        width: '100%',\n        top: item.offset\n      };\n      items.push( /*#__PURE__*/_jsxDEV(ListItem, {\n        index: i,\n        style: itemStyle,\n        ComponentType: Child,\n        onSizeChange: sizeChangeHandle\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 9\n      }, this));\n    }\n    return items;\n  };\n  const scrollHandle = event => {\n    const {\n      scrollTop\n    } = event.currentTarget;\n    setScrollOffset(scrollTop);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: containerStyle,\n    onScroll: scrollHandle,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: contentStyle,\n      children: getCurrentChildren()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 170,\n    columnNumber: 5\n  }, this);\n};\n_s2(_VariableSizeList, \"YLO7FFHwBQM79VE0W384EU/AKw0=\");\nconst App = () => {\n  const items = [];\n  const itemCount = 1000;\n  for (let i = 0; i < itemCount; i++) {\n    const height = 30 + Math.floor(Math.random() * 30);\n    const style = {\n      height,\n      width: '100%'\n    };\n    items.push( /*#__PURE__*/_jsxDEV(\"div\", {\n      className: i % 2 ? 'list-item-odd' : 'list-item-even',\n      style: style,\n      children: [\"Row \", i]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 9\n    }, this));\n  }\n  const Row = _ref => {\n    let {\n      index\n    } = _ref;\n    return items[index];\n  };\n  // 注意：这里我没有把itemSize传过去\n  return /*#__PURE__*/_jsxDEV(VariableSizeList, {\n    className: \"list\",\n    height: 200,\n    width: 200,\n    itemCount: itemCount,\n    isDynamic: true,\n    children: Row\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 196,\n    columnNumber: 9\n  }, this);\n};\n_c2 = App;\nexport default VariableSizeList;\nvar _c, _c2;\n$RefreshReg$(_c, \"ListItem\");\n$RefreshReg$(_c2, \"App\");","map":{"version":3,"names":["React","useEffect","useRef","useState","jsxDEV","_jsxDEV","measuredData","measuredDataMap","lastMeasuredItemIndex","estimatedHeight","defaultEstimatedItemSize","arguments","length","undefined","itemCount","measuredHeight","lastMeasuredItem","offset","size","unMeasuredItemsCount","totalEstimatedHeight","getItemMetaData","props","index","itemSize","itemEstimatedSize","i","currentItemSize","getStartIndex","scrollOffset","currentOffset","getEndIndex","startIndex","height","startItem","maxOffset","endIndex","currentItem","getRangeToRender","Math","max","min","ListItem","_s","style","ComponentType","domRef","resizeObserver","current","domNode","firstChild","onSizeChange","ResizeObserver","observe","unobserve","ref","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","_VariableSizeList","_s2","width","Child","setScrollOffset","setState","containerStyle","position","overflow","willChange","contentStyle","sizeChangeHandle","offsetHeight","itemMetaData","getCurrentChildren","items","item","itemStyle","top","push","scrollHandle","event","scrollTop","currentTarget","onScroll","App","floor","random","className","Row","_ref","VariableSizeList","isDynamic","_c2","$RefreshReg$"],"sources":["/Users/panan/workspace/react-playground/src/virtualList/VariableSizeList.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\n\n// 元数据\nconst measuredData = {\n  measuredDataMap: {},\n  lastMeasuredItemIndex: -1,\n};\n\nconst estimatedHeight = (defaultEstimatedItemSize = 50, itemCount) => {\n  let measuredHeight = 0;\n  const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n  // 计算已经获取过真实高度的项的高度之和\n  if (lastMeasuredItemIndex >= 0) {\n    const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n    measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;\n  }\n  // 未计算过真实高度的项数\n  const unMeasuredItemsCount = itemCount - measuredData.lastMeasuredItemIndex - 1;\n  // 预测总高度\n  // 已经渲染过的，可以得到实际高度的情况下可以直接通过计算实际高度+部分预测来判断最大高度\n  const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;\n  return totalEstimatedHeight;\n}\n\nconst getItemMetaData = (props, index) => {\n  const { itemSize, itemEstimatedSize } = props;\n  const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n  // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的size和offset\n  if (index > lastMeasuredItemIndex) {\n    let offset = 0;\n    // 计算当前能计算出来的最大offset值\n    if (lastMeasuredItemIndex > 0) {\n      const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n      offset += lastMeasuredItem.offset + lastMeasuredItem.size;\n    }\n    // 计算直到index为止，所有未计算过的项\n    for (let i = lastMeasuredItemIndex + 1; i <= index; i++) {\n      const currentItemSize = itemSize ? itemSize(i) : itemEstimatedSize;\n      measuredDataMap[i] = { size: currentItemSize, offset };\n      offset += currentItemSize;\n    }\n    // 更新已计算的项的索引值\n    measuredData.lastMeasuredItemIndex = index;\n  }\n  return measuredDataMap[index];\n};\n\nconst getStartIndex = (props, scrollOffset) => {\n  let index = 0;\n  while (true) {\n    const currentOffset = getItemMetaData(props, index).offset;\n    if (currentOffset >= scrollOffset) return index;\n    index++\n  }\n}\n\nconst getEndIndex = (props, startIndex) => {\n  const { height } = props;\n  // 获取可视区内开始的项\n  const startItem = getItemMetaData(props, startIndex);\n  // 可视区内最大的offset值\n  const maxOffset = startItem.offset + height;\n  // 开始项的下一项的offset，之后不断累加此offset，知道等于或超过最大offset，就是找到结束索引了\n  let offset = startItem.offset + startItem.size;\n  // 结束索引\n  let endIndex = startIndex;\n  // 累加offset\n  while (offset <= maxOffset) {\n    endIndex++;\n    const currentItem = getItemMetaData(props, endIndex);\n    offset += currentItem.size;\n  }\n  return endIndex;\n};\n\nconst getRangeToRender = (props, scrollOffset) => {\n  const { itemCount } = props;\n  const startIndex = getStartIndex(props, scrollOffset);\n  const endIndex = getEndIndex(props, startIndex);\n  return [\n    Math.max(0, startIndex - 2),\n    Math.min(itemCount - 1, endIndex + 2),\n    startIndex,\n    endIndex,\n  ];\n};\n\nconst ListItem = (props) => {\n  const { index, style, ComponentType } = props;\n  const domRef = useRef(null)\n  const resizeObserver = useRef(null)\n  useEffect(() => {\n    if (domRef.current) {\n      const domNode = domRef.current.firstChild;\n      const { index, onSizeChange } = props;\n      resizeObserver = new ResizeObserver(() => {\n        onSizeChange(index, domNode);\n      });\n      resizeObserver.observe(domNode);\n    }\n    return () => {\n      if (resizeObserver && domRef.current.firstChild) {\n        resizeObserver.unobserve(domRef.current.firstChild);\n      }\n    }\n  }, [])\n  return (\n    <div style={style} ref={domRef}>\n      <ComponentType index={index} />\n    </div>\n  )\n}\n\nconst _VariableSizeList = (props) => {\n  const { height, width, itemCount, itemEstimatedSize = 50, children: Child } = props;\n  const [scrollOffset, setScrollOffset] = useState(0);\n  const [, setState] = useState({});\n\n  const containerStyle = {\n    position: 'relative',\n    width,\n    height,\n    overflow: 'auto',\n    willChange: 'transform'\n  };\n\n  const contentStyle = {\n    height: estimatedHeight(itemEstimatedSize, itemCount),\n    width: '100%',\n  };\n\n  const sizeChangeHandle = (index, domNode) => {\n    const height = domNode.offsetHeight;\n    const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n    const itemMetaData = measuredDataMap[index];\n    itemMetaData.size = height;\n    let offset = 0;\n    for (let i = 0; i <= lastMeasuredItemIndex; i++) {\n      const itemMetaData = measuredDataMap[i];\n      itemMetaData.offset = offset;\n      offset += itemMetaData.size;\n    }\n    setState({});\n  }\n  // 重点看这个函数，如何在初始化的时候拿到开始和结束的 index，如何初始化高度数组，如何管理 offset 和 scrolltop 的关系\n  const getCurrentChildren = () => {\n    const [startIndex, endIndex] = getRangeToRender(props, scrollOffset)\n    const items = [];\n    for (let i = startIndex; i <= endIndex; i++) {\n      const item = getItemMetaData(props, i);\n      const itemStyle = {\n        position: 'absolute',\n        height: item.size,\n        width: '100%',\n        top: item.offset,\n      };\n      items.push(\n        <ListItem key={i} index={i} style={itemStyle} ComponentType={Child} onSizeChange={sizeChangeHandle} />\n      );\n    }\n    return items;\n  }\n\n  const scrollHandle = (event) => {\n    const { scrollTop } = event.currentTarget;\n    setScrollOffset(scrollTop);\n  }\n\n  return (\n    <div style={containerStyle} onScroll={scrollHandle}>\n      <div style={contentStyle}>\n        {getCurrentChildren()}\n      </div>\n    </div>\n  );\n};\n\n\nconst App = () => {\n  const items = [];\nconst itemCount = 1000;\nfor (let i = 0; i < itemCount; i++) {\n    const height = (30 + Math.floor(Math.random() * 30));\n    const style = {\n        height,\n        width: '100%',\n    }\n    items.push(\n        <div className={i % 2 ? 'list-item-odd' : 'list-item-even'} style={style}>Row {i}</div>\n    )\n}\n\nconst Row = ({ index }) => items[index];\n    // 注意：这里我没有把itemSize传过去\n    return (\n        <VariableSizeList\n          className=\"list\"\n          height={200}\n          width={200}\n          itemCount={itemCount}\n          isDynamic\n        >\n            {Row}\n        </VariableSizeList>\n    );\n}\n\nexport default VariableSizeList;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}