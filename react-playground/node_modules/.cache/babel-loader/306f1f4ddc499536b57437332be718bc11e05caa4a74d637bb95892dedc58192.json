{"ast":null,"code":"var _jsxFileName = \"/Users/panan/workspace/react-playground/src/virtualList/VariableSizeList.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass ListItem extends React.Component {\n  constructor(props) {\n    super(props);\n    this.domRef = /*#__PURE__*/React.createRef();\n    this.resizeObserver = null;\n  }\n  componentDidMount() {\n    if (this.domRef.current) {\n      const domNode = this.domRef.current.firstChild;\n      const {\n        index,\n        onSizeChange\n      } = this.props;\n      this.resizeObserver = new ResizeObserver(() => {\n        onSizeChange(index, domNode);\n      });\n      this.resizeObserver.observe(domNode);\n    }\n  }\n  componentWillUnmount() {\n    if (this.resizeObserver && this.domRef.current.firstChild) {\n      this.resizeObserver.unobserve(this.domRef.current.firstChild);\n    }\n  }\n  render() {\n    const {\n      index,\n      style,\n      ComponentType\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: style,\n      ref: this.domRef,\n      children: /*#__PURE__*/_jsxDEV(ComponentType, {\n        index: index\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 28,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 27,\n      columnNumber: 7\n    }, this);\n  }\n}\n// 元数据\nconst measuredData = {\n  measuredDataMap: {},\n  lastMeasuredItemIndex: -1\n};\nconst estimatedHeight = function () {\n  let defaultEstimatedItemSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n  let itemCount = arguments.length > 1 ? arguments[1] : undefined;\n  let measuredHeight = 0;\n  const {\n    measuredDataMap,\n    lastMeasuredItemIndex\n  } = measuredData;\n  // 计算已经获取过真实高度的项的高度之和\n  if (lastMeasuredItemIndex >= 0) {\n    const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n    measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;\n  }\n  // 未计算过真实高度的项数\n  const unMeasuredItemsCount = itemCount - measuredData.lastMeasuredItemIndex - 1;\n  // 预测总高度\n  // 已经渲染过的，可以得到实际高度的情况下可以直接通过计算实际高度+部分预测来判断最大高度\n  const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;\n  return totalEstimatedHeight;\n};\nconst getItemMetaData = (props, index) => {\n  const {\n    itemSize,\n    itemEstimatedSize\n  } = props;\n  const {\n    measuredDataMap,\n    lastMeasuredItemIndex\n  } = measuredData;\n  // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的size和offset\n  if (index > lastMeasuredItemIndex) {\n    let offset = 0;\n    // 计算当前能计算出来的最大offset值\n    if (lastMeasuredItemIndex > 0) {\n      const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n      offset += lastMeasuredItem.offset + lastMeasuredItem.size;\n    }\n    // 计算直到index为止，所有未计算过的项\n    for (let i = lastMeasuredItemIndex + 1; i <= index; i++) {\n      const currentItemSize = itemSize ? itemSize(i) : itemEstimatedSize;\n      measuredDataMap[i] = {\n        size: currentItemSize,\n        offset\n      };\n      offset += currentItemSize;\n    }\n    // 更新已计算的项的索引值\n    measuredData.lastMeasuredItemIndex = index;\n  }\n  return measuredDataMap[index];\n};\nconst getStartIndex = (props, scrollOffset) => {\n  let index = 0;\n  while (true) {\n    const currentOffset = getItemMetaData(props, index).offset;\n    if (currentOffset >= scrollOffset) return index;\n    index++;\n  }\n};\nconst getEndIndex = (props, startIndex) => {\n  const {\n    height,\n    itemCount\n  } = props;\n  // 获取可视区内开始的项\n  const startItem = getItemMetaData(props, startIndex);\n  // 可视区内最大的offset值\n  const maxOffset = startItem.offset + height;\n  // 开始项的下一项的offset，之后不断累加此offset，直到等于或超过最大offset，就是找到结束索引了\n  let offset = startItem.offset + startItem.size;\n  // 结束索引\n  let endIndex = startIndex;\n  // 累加offset && 增加判断越界条件\n  while (offset <= maxOffset && endIndex < itemCount - 1) {\n    endIndex++;\n    const currentItem = getItemMetaData(props, endIndex);\n    offset += currentItem.size;\n  }\n  return endIndex;\n};\nconst getRangeToRender = (props, scrollOffset) => {\n  const {\n    itemCount\n  } = props;\n  const startIndex = getStartIndex(props, scrollOffset);\n  const endIndex = getEndIndex(props, startIndex);\n  return [Math.max(0, startIndex - 2), Math.min(itemCount - 1, endIndex + 2), startIndex, endIndex];\n};\nconst _VariableSizeList = props => {\n  _s();\n  const {\n    height,\n    width,\n    itemCount,\n    itemEstimatedSize = 50,\n    children: Child\n  } = props;\n  const [scrollOffset, setScrollOffset] = useState(0);\n  const [, setState] = useState({});\n  const containerStyle = {\n    position: 'relative',\n    width,\n    height,\n    overflow: 'auto',\n    willChange: 'transform'\n  };\n  const contentStyle = {\n    height: estimatedHeight(itemEstimatedSize, itemCount),\n    width: '100%'\n  };\n\n  // 修改getCurrentChildren函数\n  const getCurrentChildren = () => {\n    const [startIndex, endIndex] = getRangeToRender(props, scrollOffset);\n    const items = [];\n    for (let i = startIndex; i <= endIndex; i++) {\n      const item = getItemMetaData(props, i);\n      const itemStyle = {\n        position: 'absolute',\n        height: item.size,\n        width: '100%',\n        top: item.offset\n      };\n      items.push( /*#__PURE__*/_jsxDEV(ListItem, {\n        index: i,\n        style: itemStyle,\n        ComponentType: Child,\n        onSizeChange: sizeChangeHandle\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 151,\n        columnNumber: 7\n      }, this));\n    }\n    return items;\n  };\n  // 增加sizeChangeHandle\n  const sizeChangeHandle = (index, domNode) => {\n    const height = domNode.offsetHeight;\n    const {\n      measuredDataMap,\n      lastMeasuredItemIndex\n    } = measuredData;\n    const itemMetaData = measuredDataMap[index];\n    itemMetaData.size = height;\n    let offset = 0;\n    for (let i = 0; i <= lastMeasuredItemIndex; i++) {\n      const itemMetaData = measuredDataMap[i];\n      itemMetaData.offset = offset;\n      offset += itemMetaData.size;\n    }\n    setState({});\n  };\n  const scrollHandle = event => {\n    const {\n      scrollTop\n    } = event.currentTarget;\n    setScrollOffset(scrollTop);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: containerStyle,\n    onScroll: scrollHandle,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: contentStyle,\n      children: getCurrentChildren()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 177,\n    columnNumber: 5\n  }, this);\n};\n_s(_VariableSizeList, \"YLO7FFHwBQM79VE0W384EU/AKw0=\");\nconst VariableSizeList = () => {\n  const items = [];\n  const itemCount = 1000;\n  for (let i = 0; i < itemCount; i++) {\n    const height = 30 + Math.floor(Math.random() * 30);\n    const style = {\n      height,\n      width: '100%'\n    };\n    items.push( /*#__PURE__*/_jsxDEV(\"div\", {\n      className: i % 2 ? 'list-item-odd' : 'list-item-even',\n      style: style,\n      children: [\"Row \", i]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 196,\n      columnNumber: 7\n    }, this));\n  }\n  const Row = _ref => {\n    let {\n      index\n    } = _ref;\n    return items[index];\n  };\n  // 注意：这里我没有把itemSize传过去\n  return /*#__PURE__*/_jsxDEV(_VariableSizeList, {\n    className: \"list\",\n    height: 200,\n    width: 200,\n    itemCount: itemCount,\n    isDynamic: true,\n    children: Row\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 203,\n    columnNumber: 5\n  }, this);\n};\n_c = VariableSizeList;\nexport default VariableSizeList;\nvar _c;\n$RefreshReg$(_c, \"VariableSizeList\");","map":{"version":3,"names":["React","useEffect","useRef","useState","jsxDEV","_jsxDEV","ListItem","Component","constructor","props","domRef","createRef","resizeObserver","componentDidMount","current","domNode","firstChild","index","onSizeChange","ResizeObserver","observe","componentWillUnmount","unobserve","render","style","ComponentType","ref","children","fileName","_jsxFileName","lineNumber","columnNumber","measuredData","measuredDataMap","lastMeasuredItemIndex","estimatedHeight","defaultEstimatedItemSize","arguments","length","undefined","itemCount","measuredHeight","lastMeasuredItem","offset","size","unMeasuredItemsCount","totalEstimatedHeight","getItemMetaData","itemSize","itemEstimatedSize","i","currentItemSize","getStartIndex","scrollOffset","currentOffset","getEndIndex","startIndex","height","startItem","maxOffset","endIndex","currentItem","getRangeToRender","Math","max","min","_VariableSizeList","_s","width","Child","setScrollOffset","setState","containerStyle","position","overflow","willChange","contentStyle","getCurrentChildren","items","item","itemStyle","top","push","sizeChangeHandle","offsetHeight","itemMetaData","scrollHandle","event","scrollTop","currentTarget","onScroll","VariableSizeList","floor","random","className","Row","_ref","isDynamic","_c","$RefreshReg$"],"sources":["/Users/panan/workspace/react-playground/src/virtualList/VariableSizeList.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\n\nclass ListItem extends React.Component {\n  constructor(props) {\n    super(props);\n    this.domRef = React.createRef();\n    this.resizeObserver = null;\n  }\n  componentDidMount() {\n    if (this.domRef.current) {\n      const domNode = this.domRef.current.firstChild;\n      const { index, onSizeChange } = this.props;\n      this.resizeObserver = new ResizeObserver(() => {\n        onSizeChange(index, domNode);\n      });\n      this.resizeObserver.observe(domNode);\n    }\n  }\n  componentWillUnmount() {\n    if (this.resizeObserver && this.domRef.current.firstChild) {\n      this.resizeObserver.unobserve(this.domRef.current.firstChild);\n    }\n  }\n  render() {\n    const { index, style, ComponentType } = this.props;\n    return (\n      <div style={style} ref={this.domRef}>\n        <ComponentType index={index} />\n      </div>\n    )\n  }\n}\n// 元数据\nconst measuredData = {\n  measuredDataMap: {},\n  lastMeasuredItemIndex: -1,\n};\n\nconst estimatedHeight = (defaultEstimatedItemSize = 50, itemCount) => {\n  let measuredHeight = 0;\n  const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n  // 计算已经获取过真实高度的项的高度之和\n  if (lastMeasuredItemIndex >= 0) {\n    const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n    measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;\n  }\n  // 未计算过真实高度的项数\n  const unMeasuredItemsCount = itemCount - measuredData.lastMeasuredItemIndex - 1;\n  // 预测总高度\n  // 已经渲染过的，可以得到实际高度的情况下可以直接通过计算实际高度+部分预测来判断最大高度\n  const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;\n  return totalEstimatedHeight;\n}\n\nconst getItemMetaData = (props, index) => {\n  const { itemSize, itemEstimatedSize } = props;\n  const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n  // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的size和offset\n  if (index > lastMeasuredItemIndex) {\n    let offset = 0;\n    // 计算当前能计算出来的最大offset值\n    if (lastMeasuredItemIndex > 0) {\n      const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n      offset += lastMeasuredItem.offset + lastMeasuredItem.size;\n    }\n    // 计算直到index为止，所有未计算过的项\n    for (let i = lastMeasuredItemIndex + 1; i <= index; i++) {\n      const currentItemSize = itemSize ? itemSize(i) : itemEstimatedSize;\n      measuredDataMap[i] = { size: currentItemSize, offset };\n      offset += currentItemSize;\n    }\n    // 更新已计算的项的索引值\n    measuredData.lastMeasuredItemIndex = index;\n  }\n  return measuredDataMap[index];\n};\n\nconst getStartIndex = (props, scrollOffset) => {\n  let index = 0;\n  while (true) {\n    const currentOffset = getItemMetaData(props, index).offset;\n    if (currentOffset >= scrollOffset) return index;\n    index++\n  }\n}\n\nconst getEndIndex = (props, startIndex) => {\n  const { height, itemCount } = props;\n  // 获取可视区内开始的项\n  const startItem = getItemMetaData(props, startIndex);\n  // 可视区内最大的offset值\n  const maxOffset = startItem.offset + height;\n  // 开始项的下一项的offset，之后不断累加此offset，直到等于或超过最大offset，就是找到结束索引了\n  let offset = startItem.offset + startItem.size;\n  // 结束索引\n  let endIndex = startIndex;\n  // 累加offset && 增加判断越界条件\n  while (offset <= maxOffset && endIndex < (itemCount - 1)) {\n    endIndex++;\n    const currentItem = getItemMetaData(props, endIndex);\n    offset += currentItem.size;\n  }\n  return endIndex;\n};\n\nconst getRangeToRender = (props, scrollOffset) => {\n  const { itemCount } = props;\n  const startIndex = getStartIndex(props, scrollOffset);\n  const endIndex = getEndIndex(props, startIndex);\n  return [\n    Math.max(0, startIndex - 2),\n    Math.min(itemCount - 1, endIndex + 2),\n    startIndex,\n    endIndex,\n  ];\n};\n\n\n\nconst _VariableSizeList = (props) => {\n  const { height, width, itemCount, itemEstimatedSize = 50, children: Child } = props;\n  const [scrollOffset, setScrollOffset] = useState(0);\n  const [, setState] = useState({});\n\n  const containerStyle = {\n    position: 'relative',\n    width,\n    height,\n    overflow: 'auto',\n    willChange: 'transform'\n  };\n\n  const contentStyle = {\n    height: estimatedHeight(itemEstimatedSize, itemCount),\n    width: '100%',\n  };\n\n// 修改getCurrentChildren函数\nconst getCurrentChildren = () => {\n  const [startIndex, endIndex] = getRangeToRender(props, scrollOffset)\n  const items = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const item = getItemMetaData(props, i);\n    const itemStyle = {\n      position: 'absolute',\n      height: item.size,\n      width: '100%',\n      top: item.offset,\n    };\n    items.push(\n      <ListItem key={i} index={i} style={itemStyle} ComponentType={Child} onSizeChange={sizeChangeHandle} />\n    );\n  }\n  return items;\n}\n// 增加sizeChangeHandle\nconst sizeChangeHandle = (index, domNode) => {\n  const height = domNode.offsetHeight;\n  const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n  const itemMetaData = measuredDataMap[index];\n  itemMetaData.size = height;\n  let offset = 0;\n  for (let i = 0; i <= lastMeasuredItemIndex; i++) {\n    const itemMetaData = measuredDataMap[i];\n    itemMetaData.offset = offset;\n    offset += itemMetaData.size;\n  }\n  setState({});\n}\n\n  const scrollHandle = (event) => {\n    const { scrollTop } = event.currentTarget;\n    setScrollOffset(scrollTop);\n  }\n\n  return (\n    <div style={containerStyle} onScroll={scrollHandle}>\n      <div style={contentStyle}>\n        {getCurrentChildren()}\n      </div>\n    </div>\n  );\n};\n\n\nconst VariableSizeList = () => {\n  const items = [];\n  const itemCount = 1000;\n  for (let i = 0; i < itemCount; i++) {\n    const height = (30 + Math.floor(Math.random() * 30));\n    const style = {\n      height,\n      width: '100%',\n    }\n    items.push(\n      <div className={i % 2 ? 'list-item-odd' : 'list-item-even'} style={style}>Row {i}</div>\n    )\n  }\n\n  const Row = ({ index }) => items[index];\n  // 注意：这里我没有把itemSize传过去\n  return (\n    <_VariableSizeList\n      className=\"list\"\n      height={200}\n      width={200}\n      itemCount={itemCount}\n      isDynamic\n    >\n      {Row}\n    </_VariableSizeList>\n  );\n}\n\nexport default VariableSizeList;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}